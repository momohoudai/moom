#ifndef SUI_PACK_H
#define SUI_PACK_H

#include <stdio.h>
#include "sui_atlas.h"
#include "karu.h"
#include "momo_common.h"
#include "momo_shapes.h"
#include "momo_ttf.h"
#include "momo_strings.h"

struct Sui_Packer_Bitmap {
  U32 width;
  U32 height;
  U32* pixels;
  const C8* id_name;
};

struct Sui_Packer_Sprite {
  const C8* file_name;
  const C8* id_name;
  U32 bitmap_id;
  RP_Rect* rect;
};

struct Sui_Packer_Font {
  const char* id_name;
  const char* file_name;
  U32 bitmap_id;

  U32 first_atlas_font_glyph_id;
  U32 ope_atlas_font_glyph_id;
  F32 glyph_height;
  U32 highest_codepoint; // TODO: we should get rid of this?
};

struct Sui_Packer_Font_Glyph{ 
  U32 codepoint; 
  RP_Rect* rect;
};

struct Sui_Packer_Sound {
  const char* sound_id_name;
  WAV* wav;
};


struct Sui_Packer {
  FILE* pack_id_file;
  U32 pack_count;
  const char* current_pack_id_name;

  Bump_Allocator* allocator;

  FILE* bitmap_id_file;
  FILE* font_id_file;
  FILE* sprite_id_file;
  FILE* sound_id_file;
  

  U32 bitmap_count;
  Sui_Packer_Bitmap bitmaps[32];
  
  U32 sprite_count;
  Sui_Packer_Sprite sprites[128];
  
  U32 sound_count;
  Sui_Packer_Sound sounds[64];

  Sui_Packer_Font* current_font;
  
  U32 font_count;
  U32 font_glyph_count;
  Sui_Packer_Font fonts[64];
  Sui_Packer_Font_Glyph font_glyphs[256];

  // For atlas building
  U32 current_atlas_bitmap_id;
  U32 first_atlas_sprite_id;
  U32 ope_atlas_sprite_id;
  U32 first_atlas_font_id;
  U32 ope_atlas_font_id;
  U32 current_atlas_font_id; 
};


/////////////////////////////////////////////////////
// IMPLEMENTATION
//
static B32
begin_packer(Sui_Packer* p,
             Bump_Allocator* allocator,
             const char* pack_id_filename,
             const char* bitmap_id_filename,
             const char* sprite_id_filename,
             const char* font_id_filename,
             const char* sound_id_filename)
{
  p->allocator = allocator;

  p->pack_id_file = fopen(pack_id_filename, "w");
  p->bitmap_id_file = fopen(bitmap_id_filename, "w");
  p->font_id_file = fopen(font_id_filename, "w");
  p->sprite_id_file = fopen(sprite_id_filename, "w");
  p->sound_id_file = fopen(sound_id_filename, "w");

  if (!p->pack_id_file) return false;
  if (!p->bitmap_id_file) return false;
  if (!p->font_id_file) return false;
  if (!p->sprite_id_file) return false;
  if (!p->sound_id_file) return false;
  
  // boiler plate:
  {
    String8 boiler = str8_from_lit("// Generated by sui\n");
    fwrite(boiler.e, boiler.count, 1, p->pack_id_file);
    fwrite(boiler.e, boiler.count, 1, p->bitmap_id_file);
    fwrite(boiler.e, boiler.count, 1, p->font_id_file);
    fwrite(boiler.e, boiler.count, 1, p->sprite_id_file);
    fwrite(boiler.e, boiler.count, 1, p->sound_id_file);
  }
  
  
  String8 str = {};
  str = str8_from_lit("enum Pack_ID {\n");
  fwrite(str.e, str.count, 1, p->pack_id_file);
  str = str8_from_lit("enum Bitmap_ID {\n");
  fwrite(str.e, str.count, 1, p->bitmap_id_file);
  str = str8_from_lit("enum Font_ID {\n");
  fwrite(str.e, str.count, 1, p->font_id_file);
  str = str8_from_lit("enum Sprite_ID {\n");
  fwrite(str.e, str.count, 1, p->sprite_id_file);
  str = str8_from_lit("enum Sound_ID {\n");
  fwrite(str.e, str.count, 1, p->sound_id_file);

  return true;
}


static void
end_packer(Sui_Packer* p) {
  String8 str = {};
  str = str8_from_lit("};");
  fwrite(str.e, str.count, 1, p->pack_id_file);
  fwrite(str.e, str.count, 1, p->bitmap_id_file);
  fwrite(str.e, str.count, 1, p->font_id_file);
  fwrite(str.e, str.count, 1, p->sprite_id_file);
  fwrite(str.e, str.count, 1, p->sound_id_file);
  
  // close the files
  fclose(p->pack_id_file);
  fclose(p->bitmap_id_file);
  fclose(p->font_id_file);
  fclose(p->sprite_id_file);
  fclose(p->sound_id_file);
}

static void
begin_asset_pack(Sui_Packer* p)
{ 
  p->bitmap_count = 0;
  p->sprite_count = 0;
  p->current_font = 0;
  p->font_count = 0;
  p->font_glyph_count = 0;
}

#if 0
static U32
push_bitmap(Sui_Packer* p, 
            U32 w, U32 h, 
            U32* pixels, 
            const char* bitmap_id_name) 
{
  assert(p->bitmap_count < array_count(p->bitmaps));
  
  Sui_Packer_Bitmap* bitmap = p->bitmaps + p->bitmap_count;
  bitmap->width = w;
  bitmap->height = h;
  bitmap->pixels = pixels;
  bitmap->bitmap_id_name = bitmap_id_name;
  
  return p->bitmap_count++;
}
#endif

static void 
begin_atlas(Sui_Packer *p) {
  assert(p->bitmap_count < array_count(p->bitmaps));
  p->current_atlas_bitmap_id = p->bitmap_count++;

  p->first_atlas_sprite_id = p->sprite_count;
  p->ope_atlas_sprite_id = p->first_atlas_sprite_id;

  p->first_atlas_font_id = p->font_count;
  p->ope_atlas_font_id = p->first_atlas_font_id;
}


static void
push_atlas_sprite(Sui_Packer* p, const char* id_name, const char* file_name) {
  assert(p->sprite_count < array_count(p->sprites));
  Sui_Packer_Sprite* s = p->sprites + p->sprite_count++;
  s->file_name = file_name;
  s->id_name = id_name;
  s->bitmap_id = p->current_atlas_bitmap_id;

  ++p->ope_atlas_sprite_id;
}

#if 0 
static void
push_atlas_font(Sui_Packer* p, 
                const C8* id_name,
                const C8* file_name, 
                U32* codepoints, 
                U32 codepoint_count)
{
  assert(p->font_count < array_count(p->fonts));
  Sui_Packer_Font* f = p->fonts + p->font_count++;
  f->id_name = id_name;
  f->file_name = file_name;
  f->codepoints = codepoints;
  f->codepoint_count = codepoint_count;
  f->bitmap_id = p->current_atlas_bitmap_id;

  ++p->ope_atlas_font_id;
}
#endif



static void
begin_atlas_font(Sui_Packer* p,
                 const C8* id_name,
                 const C8* file_name,
                 F32 glyph_height)
{
  assert(p->font_count < array_count(p->fonts));
  p->current_atlas_font_id = p->font_count++;

  Sui_Packer_Font* f = p->fonts + p->current_atlas_font_id;
  f->id_name = id_name;
  f->file_name = file_name;
  f->glyph_height = glyph_height;
  f->highest_codepoint = 0;

  f->first_atlas_font_glyph_id = p->font_glyph_count;
  f->ope_atlas_font_glyph_id = f->first_atlas_font_glyph_id;

  ++p->ope_atlas_font_id;
}

static void 
end_atlas_font(Sui_Packer* p) {
  // Do nothing?
}

static void 
push_atlas_font_glyph(Sui_Packer* p, U32 codepoint) {
  assert(p->font_glyph_count < array_count(p->font_glyphs));
  Sui_Packer_Font_Glyph* g = p->font_glyphs + p->font_glyph_count++;
  g->codepoint = codepoint;

  Sui_Packer_Font* f = p->fonts + p->current_atlas_font_id;
  f->ope_atlas_font_glyph_id = p->font_glyph_count;

  if (codepoint > f->highest_codepoint) {
    f->highest_codepoint = codepoint;
  }
}

static B32 
end_atlas(Sui_Packer* p, const char* id_name, U32 width, U32 height)
{
  Sui_Packer_Bitmap* bmp = p->bitmaps + p->current_atlas_bitmap_id;

  bmp->width = width;
  bmp->height = height;
  bmp->pixels = ba_push_arr(U32, p->allocator, width * height);
  bmp->id_name = id_name;

  if (!bmp->pixels) return false; 
   
  // Count the amount of rects
  U32 rect_count = p->ope_atlas_sprite_id - p->first_atlas_sprite_id;
  {
    // Figure out font
    for (U32 font_id = p->first_atlas_font_id;
         font_id < p->ope_atlas_font_id;
         ++font_id)
    {
      Sui_Packer_Font* f = p->fonts + font_id;
      rect_count += f->ope_atlas_font_glyph_id - f->first_atlas_font_glyph_id;
    }
  }

  if (rect_count == 0) return false;

  RP_Rect* rects = ba_push_arr(RP_Rect, p->allocator, rect_count);
  if (!rects) return false;

  ba_set_revert_point(p->allocator);
  U32 rect_index = 0;

  // Figure out font
  for (U32 font_id = p->first_atlas_font_id;
       font_id < p->ope_atlas_font_id;
       ++font_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Font* font = p->fonts + font_id;

    make(TTF, ttf);
    if (!sui_read_font_from_file(ttf, font->file_name, p->allocator))
      return false; 

    F32 s = ttf_get_scale_for_pixel_height(ttf, font->glyph_height);
   
    for (U32 glyph_id = font->first_atlas_font_glyph_id;
         glyph_id < font->ope_atlas_font_glyph_id;
         ++glyph_id)
    {
      Sui_Packer_Font_Glyph* g = p->font_glyphs + glyph_id;
      U32 cp = g->codepoint;
      U32 glyph_index = ttf_get_glyph_index(ttf, cp);
      Rect2 box = ttf_get_glyph_box(ttf, glyph_index, s);
      V2U dims = ttf_get_bitmap_dims_from_glyph_box(box);
 
      RP_Rect* rect = rects + rect_index++;
      rect->w = dims.w;
      rect->h = dims.h;

      g->rect = rect;
    }
  }


  for (U32 sprite_id = p->first_atlas_sprite_id;
       sprite_id < p->ope_atlas_sprite_id;
       ++sprite_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Sprite* sprite = p->sprites + sprite_id;
    make(Block, mem);
    make(PNG, png);
    if (!sui_read_file_to_blk(mem, sprite->file_name, p->allocator))
      return false;
    if (!png_read(png, mem->data, mem->size)) 
      return false;
   
    RP_Rect* rect = rects + rect_index++;
    rect->w = png->width;
    rect->h = png->height;

    sprite->rect = rect;
  }

  // Pack the rects
  rp_pack(rects, rect_count, 1, bmp->width, bmp->height, RP_SORT_TYPE_HEIGHT, p->allocator);

  // Rasterize the bitmap
  // Sprites
  for (U32 sprite_id = p->first_atlas_sprite_id;
       sprite_id < p->ope_atlas_sprite_id;
       ++sprite_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Sprite* sprite = p->sprites + sprite_id;
    make(Block, mem);
    make(PNG, png);
    if (!sui_read_file_to_blk(mem, sprite->file_name, p->allocator))
      return false;
    if (!png_read(png, mem->data, mem->size)) 
      return false;
    Image32 sprite_bmp = png_to_img32(png, p->allocator);
    if (!img32_ok(sprite_bmp)) continue;

    RP_Rect* rect = sprite->rect;
    for (UMI y = rect->y, j = 0; y < rect->y + rect->h; ++y) {
      for (UMI x = rect->x; x < rect->x + rect->w; ++x) {
        UMI index = (x + y *  bmp->width);
        ((U32*)(bmp->pixels))[index] = ((U32*)(sprite_bmp.pixels))[j++];
      }
    }
  }

  // Font Glyphs
  for (U32 font_id = p->first_atlas_font_id;
       font_id < p->ope_atlas_font_id;
       ++font_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Font* f = p->fonts + font_id;

    // TODO: Cache this into Sui_Packer_Font?
    make(TTF, ttf);
    if (!sui_read_font_from_file(ttf, f->file_name, p->allocator))
      return false; 

    for (U32 glyph_id = f->first_atlas_font_glyph_id;
         glyph_id < f->ope_atlas_font_glyph_id;
         ++glyph_id)
    {
      Sui_Packer_Font_Glyph* g = p->font_glyphs + glyph_id;
      F32 scale = ttf_get_scale_for_pixel_height(ttf, f->glyph_height);
      U32 glyph_index = ttf_get_glyph_index(ttf, g->codepoint);

      Image32 glyph_bmp = ttf_rasterize_glyph(ttf, glyph_index, scale, p->allocator);
      if (!img32_ok(glyph_bmp)) continue;

      RP_Rect* rect = g->rect;
      for (UMI y = rect->y, j = 0; y < rect->y + rect->h; ++y) {
        for (UMI x = rect->x; x < rect->x + rect->w; ++x) {
          UMI index = (x + y *  bmp->width);
          ((U32*)(bmp->pixels))[index] = ((U32*)(glyph_bmp.pixels))[j++];
        }
      }
    }
  }

#if 1
  // test
  {
    Image32 bitmap = {};
    bitmap.width = bmp->width;
    bitmap.height = bmp->height;
    bitmap.pixels = bmp->pixels; 

    ba_set_revert_point(p->allocator);
    sui_log("Writing test png file...\n");
    Block png_blk = png_write(bitmap, p->allocator);
    if (!blk_ok(png_blk)) return 1;
    sui_write_file_from_blk("test.png", png_blk);
  }
#endif
  return true;
}


#if 0
static U32 
add_sprite(Sui_Packer* p, 
           U32 bitmap_id, 
           Rect2U texel_uv, 
           const char* sprite_id_name) 
{
  assert(p->sprite_count < array_count(p->sprites));
  
  Sui_Packer_Sprite* sprite = p->sprites + p->sprite_count;
  sprite->bitmap_id = bitmap_id;
  sprite->texel_uv = texel_uv;
  sprite->sprite_id_name = sprite_id_name;
  return p->sprite_count++;
}

static U32
begin_font(Sui_Packer* p) 
{ 
  assert(p->font_count < array_count(p->fonts));
  assert(p->current_font == nullptr);
  Sui_Packer_Font* font = p->fonts + p->font_count;
  font->glyph_start_index = p->font_glyph_count;
  font->one_past_glyph_end_index = font->glyph_start_index;
  
  p->current_font = font;
  return p->font_count++;
}

static void
push_glyph(Sui_Packer* p, Rect2U texel_uv, Rect2 uv, U32 codepoint) {
  Sui_Packer_Font* font = p->current_font;
  assert(font);
  assert(p->font_glyph_count < array_count(p->font_glyphs));
  
  Sui_Packer_Font_Glyph* glyph = p->font_glyphs + p->font_glyph_count++;
  glyph->texel_uv = texel_uv;
  glyph->uv = uv;
  glyph->codepoint = codepoint;
  
  if (codepoint > font->highest_codepoint) {
    font->highest_codepoint = codepoint;
  }
  
  // if there's no glyphs yet
  ++font->one_past_glyph_end_index;
}



static void
end_font(Sui_Packer* p, const char* font_id_name, const char* font_file_name, U32 bitmap_id) {
  Sui_Packer_Font* font = p->current_font;
  assert(font);
  font->font_id_name = font_id_name;
  font->bitmap_id = bitmap_id;
  font->font_file_name = font_file_name;
  
  font = nullptr;
  p->current_font = nullptr;
  
}
#endif

#if 0
static void
push_sound(Sui_Packer* p, const char* sound_id_name, WAV* wav) { 
  assert(p->sound_count < array_count(p->sounds));

  Sui_Packer_Sound* sound = p->sounds + p->sound_count++;
  sound->sound_id_name = sound_id_name;
  sound->wav = wav;
}
#endif


#if 0
static void
add_atlas(Sui_Packer* p, Sui_Atlas* atlas) {
  U32 real_bitmap_id = add_bitmap(p, 
                                  atlas->bitmap.width,
                                  atlas->bitmap.height,
                                  atlas->bitmap.pixels,
                                  atlas->bitmap_id_name);
  U32 bitmap_id = 0 << 16 | real_bitmap_id;
  
  for (U32 sprite_index = 0; 
       sprite_index < atlas->sprite_count;
       ++sprite_index) 
  {
    Sui_Atlas_Sprite* sas = atlas->sprites + sprite_index;
    
    Rect2 uv = {};
    uv.min.x = (F32)sas->rect->x / atlas->bitmap.width;
    uv.min.y = (F32)sas->rect->y / atlas->bitmap.height;
    uv.max.x = (F32)(sas->rect->x+sas->rect->w) / atlas->bitmap.width;
    uv.max.y = (F32)(sas->rect->y+sas->rect->h) / atlas->bitmap.height;
    
    Rect2U texel_uv = {};
    texel_uv.min.x = sas->rect->x;
    texel_uv.min.y = sas->rect->y;
    texel_uv.max.x = sas->rect->x + sas->rect->w;
    texel_uv.max.y = sas->rect->y + sas->rect->h;
    
    add_sprite(p, bitmap_id, texel_uv, sas->sprite_id_name);
  }
  
  for (U32 font_index = 0; 
       font_index < atlas->font_count;
       ++font_index) 
  {
    begin_font(p);
    Sui_Atlas_Font* saf = atlas->fonts + font_index;
    
    U32 highest_codepoint = 0;
    for (U32 rect_index = 0;
         rect_index < saf->rect_count; 
         ++rect_index) 
    {
      RP_Rect* rect = saf->glyph_rects + rect_index;
      Sui_Atlas_Context* sac = saf->glyph_rect_contexts + rect_index;
      
      Rect2 uv = {};
      uv.min.x = (F32)rect->x / atlas->bitmap.width;
      uv.min.y = (F32)rect->y / atlas->bitmap.height;
      uv.max.x = (F32)(rect->x+rect->w) / atlas->bitmap.width;
      uv.max.y = (F32)(rect->y+rect->h) / atlas->bitmap.height;
      
      Rect2U texel_uv = {};
      texel_uv.min.x = rect->x;
      texel_uv.min.y = rect->y;
      texel_uv.max.x = rect->x + rect->w;
      texel_uv.max.y = rect->y + rect->h;
      
      push_glyph(p, texel_uv, uv, sac->font_glyph.codepoint);
    }
    
    end_font(p, saf->font_id_name, saf->font_file_name, bitmap_id);
  }
  
}
#endif



static B32
end_asset_pack(Sui_Packer* p, 
               const char* pack_id_name,
               const char* filename) 

{
  sui_log("Starting writing to %s\n", filename);
  defer { sui_log("End writing to %s\n", filename); };
  
  FILE* file = fopen(filename, "wb");
  if (!file) return false;
  defer { fclose(file); };
  
  // Packed in this order:
  // - Bitmap, Sprite, Font, Sound, Msgs
  Karu_Header header = {};
  {
    header.signature = KARU_SIGNATURE;
    header.font_count = p->font_count;
    header.sprite_count = p->sprite_count;
    header.bitmap_count = p->bitmap_count;
    header.sound_count = p->sound_count;
    header.offset_to_bitmaps = sizeof(Karu_Header);
    header.offset_to_sprites = header.offset_to_bitmaps + sizeof(Karu_Bitmap)*p->bitmap_count;
    header.offset_to_fonts = header.offset_to_sprites + sizeof(Karu_Sprite)*p->sprite_count;
    header.offset_to_sounds = header.offset_to_fonts + sizeof(Karu_Sprite)*p->font_count;
    fwrite(&header, sizeof(header), 1, file);
  }
  
  U32 offset_to_data = header.offset_to_fonts + sizeof(Karu_Font)*p->font_count;
 
  sb8_make(builder, 256);
  for (U32 bitmap_index = 0;
       bitmap_index < p->bitmap_count;
       ++bitmap_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing bitmap %u\n", bitmap_index);
    Sui_Packer_Bitmap* pb = p->bitmaps + bitmap_index;
    Karu_Bitmap kb = {};
    kb.width = pb->width;
    kb.height = pb->height;
    kb.offset_to_data = offset_to_data;
    fwrite(&kb, sizeof(Karu_Bitmap), 1, file);
    
    
    U32 current_pos = ftell(file);
    U32 image_size = kb.width * kb.height * 4;
    fseek(file, kb.offset_to_data, SEEK_SET);
    fwrite(pb->pixels, image_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += image_size;
    
    // Write to bitmap_id file
    String8 format = str8_from_lit("%s = %s << 16 | %u,\n");
    sb8_push_fmt(builder, format, pb->id_name, pack_id_name, bitmap_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    sb8_clear(builder);
  }
  

  for (U32 sprite_index = 0;
       sprite_index < p->sprite_count;
       ++sprite_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sprite %u\n", sprite_index);
    Sui_Packer_Sprite* ps = p->sprites + sprite_index;
    Sui_Packer_Bitmap* pb = p->bitmaps + ps->bitmap_id;

    // Convert to rect to texel
    RP_Rect* rect = ps->rect;
    Rect2U texel_uv = {};
    texel_uv.min.x = rect->x;
    texel_uv.min.y = rect->y;
    texel_uv.max.x = rect->x + rect->w;
    texel_uv.max.y = rect->y + rect->h;

    // Write sprite data
    Karu_Sprite ks = {};
    ks.bitmap_id = ps->bitmap_id;
    ks.texel_uv = texel_uv;
    fwrite(&ks, sizeof(Karu_Sprite), 1, file);
    
    // Add to sprite id
    String8 format = str8_from_lit("%s = %s << 16 | %u,\n");
    sb8_push_fmt(builder, format, ps->id_name, pack_id_name, sprite_index);
    fwrite(builder->e, builder->count, 1, p->sprite_id_file);
    sb8_clear(builder);
  }
 
  for (U32 font_index = 0;
       font_index < p->font_count;
       ++font_index) 
  {
    ba_set_revert_point(p->allocator);
    sui_create_log_section_until_scope;
    sui_log("Writing font %u\n", font_index);
    Sui_Packer_Font* pf = p->fonts + font_index;
    Karu_Font kf = {};
    
    kf.bitmap_id = pf->bitmap_id;
    kf.highest_codepoint = pf->highest_codepoint; // ????????
    kf.glyph_count = pf->ope_atlas_font_glyph_id - pf->first_atlas_font_glyph_id;
    kf.offset_to_data = offset_to_data;
    fwrite(&kf, sizeof(Karu_Font), 1, file);
    
    U32 current_pos = ftell(file);
    fseek(file, kf.offset_to_data, SEEK_SET);

    make(TTF, ttf);
    if(!sui_read_font_from_file(ttf, pf->file_name, p->allocator))
      return false;
   
    for (U32 glyph_index = pf->first_atlas_font_glyph_id;
         glyph_index < pf->ope_atlas_font_glyph_id;
         ++glyph_index) 
    {
      Sui_Packer_Font_Glyph* pfg = p->font_glyphs + glyph_index;
      
      // Convert to rect to texel
      RP_Rect* rect = pfg->rect;
      Rect2U texel_uv = {};
      texel_uv.min.x = rect->x;
      texel_uv.min.y = rect->y;
      texel_uv.max.x = rect->x + rect->w;
      texel_uv.max.y = rect->y + rect->h;

      Karu_Font_Glyph kfg = {};
      kfg.texel_uv = texel_uv;
      kfg.codepoint = pfg->codepoint;

      U32 ttf_glyph_index = ttf_get_glyph_index(ttf,kfg.codepoint);
      F32 s = ttf_get_scale_for_pixel_height(ttf, 1.f);
      kfg.box = ttf_get_glyph_box(ttf, ttf_glyph_index, s);
      fwrite(&kfg, sizeof(kfg), 1, file);
      offset_to_data += sizeof(kfg);
    }
    
    for (U32 pgi1 = pf->first_atlas_font_glyph_id;
         pgi1 < pf->ope_atlas_font_glyph_id;
         ++pgi1) 
    {
      F32 pixel_scale = ttf_get_scale_for_pixel_height(ttf, 1.f);
      
      Sui_Packer_Font_Glyph* pfg1 = p->font_glyphs + pgi1;
      for (U32 pgi2 = pf->first_atlas_font_glyph_id;
           pgi2 < pf->ope_atlas_font_glyph_id;
           ++pgi2) 
      {
        Sui_Packer_Font_Glyph* pfg2 = p->font_glyphs + pgi2;
        
        U32 cp1 = pfg1->codepoint;
        U32 cp2 = pfg2->codepoint;
        
        U32 gi1 = ttf_get_glyph_index(ttf, cp1);
        U32 gi2 = ttf_get_glyph_index(ttf, cp2);
        
        auto g1_metrics = ttf_get_glyph_horiozontal_metrics(ttf, gi1);
        S32 raw_kern = ttf_get_glyph_kerning(ttf, gi1, gi2);
        
        F32 advance_width = (F32)g1_metrics.advance_width * pixel_scale;
        F32 kerning = (F32)raw_kern * pixel_scale;
        
        F32 advance = advance_width + kerning;
        fwrite(&advance, sizeof(advance), 1, file);
        offset_to_data += sizeof(advance);
        
      }
      
    }
    
    
    fseek(file, current_pos, SEEK_SET);
    
    // write font id
    String8 format = str8_from_lit("%s = %s << 16 | %u,\n");
    sb8_push_fmt(builder, format, pf->id_name, pack_id_name, font_index);
    fwrite(builder->e, builder->count, 1, p->font_id_file);
    sb8_clear(builder);
  }


#if 0
  for(U32 sound_index = 0;
      sound_index < p->sound_count;
      ++sound_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sound %u\n", sound_index);
    Sui_Packer_Sound* ps = p->sounds + sound_index;
    Karu_Sound ks = {};
    ks.offset_to_data = offset_to_data;
    ks.data_count = ps->wav->data_chunk.size / sizeof(S16);
    fwrite(&ks, sizeof(Karu_Sound), 1, file);

    U32 current_pos = ftell(file);
    U32 data_size = ps->wav->data_chunk.size;
    fseek(file, ks.offset_to_data, SEEK_SET);
    fwrite(ps->wav->data, data_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += data_size;

    // Write to sound_id file
    String8 format = str8_from_lit("%s = %s << 16 | %u,\n");
    sb8_push_fmt(builder, format, ps->sound_id_name, pack_id_name, sound_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    clear(builder);

  }

  
  // Write the header
  fseek(file, 0, SEEK_SET);
  fwrite(&header, sizeof(header), 1, file);
#endif
  
  // Write the pack id
  {
    String8 format = str8_from_lit("%s = %u,\n");
    sb8_push_fmt(builder, format, pack_id_name, p->pack_count);
    fwrite(builder->e, builder->count, 1, p->pack_id_file);
    sb8_clear(builder);
    ++p->pack_count;
    
  }
  
  return true;
  
}


#endif //SUI_PACK_H
