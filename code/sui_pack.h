#ifndef SUI_PACK_H
#define SUI_PACK_H

#include <stdio.h>
#include "sui_atlas.h"
#include "karu.h"
#include "momo_common.h"
#include "momo_shapes.h"
#include "momo_ttf.h"
#include "momo_strings.h"

struct Packer_Font_Glyph {
  Rect2 uv;
  Rect2U texel_uv;
  U32 codepoint;
};

struct Packer_Font {
  U32 bitmap_id;
  U32 highest_codepoint;
  const char* font_file_name;
  
  U32 glyph_start_index;
  U32 one_past_glyph_end_index;
  
  const char* font_id_name;
};

struct Packer_Bitmap {
  U32 width;
  U32 height;
  U32* pixels;
  const char* bitmap_id_name;
};


struct Packer_Sprite {
  U32 bitmap_id;
  Rect2U texel_uv;
  const char* sprite_id_name;
};

struct Packer_Sound {
  const char* sound_id_name;
  WAV* wav;
};


struct Sui_Packer {
  FILE* pack_id_file;
  U32 pack_count;
  const char* current_pack_id_name;
  
  FILE* bitmap_id_file;
  FILE* font_id_file;
  FILE* sprite_id_file;
  FILE* sound_id_file;
  
  U32 bitmap_count;
  Packer_Bitmap bitmaps[128];
  
  U32 sprite_count;
  Packer_Sprite sprites[256];
  
  U32 sound_count;
  Packer_Sound sounds[256];

  Packer_Font* current_font;
  
  U32 font_count;
  U32 font_glyph_count;
  Packer_Font fonts[256];
  Packer_Font_Glyph font_glyphs[256];
  
};

/////////////////////////////////////////////////////
// IMPLEMENTATION
//
static B32
begin_packer(Sui_Packer* packer,
             const char* pack_id_filename,
             const char* bitmap_id_filename,
             const char* sprite_id_filename,
             const char* font_id_filename,
             const char* sound_id_filename)
{
  Sui_Packer ret = {};
  
  packer->pack_id_file = fopen(pack_id_filename, "w");
  packer->bitmap_id_file = fopen(bitmap_id_filename, "w");
  packer->font_id_file = fopen(font_id_filename, "w");
  packer->sprite_id_file = fopen(sprite_id_filename, "w");
  packer->sound_id_file = fopen(sound_id_filename, "w");
 

  if (!packer->pack_id_file) return false;
  if (!packer->bitmap_id_file) return false;
  if (!packer->font_id_file) return false;
  if (!packer->sprite_id_file) return false;
  if (!packer->sound_id_file) return false;
  
  // boiler plate:
  {
    String boiler = string_from_lit("// Generated by sui\n");
    fwrite(boiler.e, boiler.count, 1, packer->pack_id_file);
    fwrite(boiler.e, boiler.count, 1, packer->bitmap_id_file);
    fwrite(boiler.e, boiler.count, 1, packer->font_id_file);
    fwrite(boiler.e, boiler.count, 1, packer->sprite_id_file);
    fwrite(boiler.e, boiler.count, 1, packer->sound_id_file);
  }
  
  
  String str = {};
  str = string_from_lit("enum Pack_ID {\n");
  fwrite(str.e, str.count, 1, packer->pack_id_file);
  str = string_from_lit("enum Bitmap_ID {\n");
  fwrite(str.e, str.count, 1, packer->bitmap_id_file);
  str = string_from_lit("enum Font_ID {\n");
  fwrite(str.e, str.count, 1, packer->font_id_file);
  str = string_from_lit("enum Sprite_ID {\n");
  fwrite(str.e, str.count, 1, packer->sprite_id_file);
  str = string_from_lit("enum Sound_ID {\n");
  fwrite(str.e, str.count, 1, packer->sound_id_file);

  return true;
}


static void
end_packer(Sui_Packer* p) {
  
  String str = {};
  str = string_from_lit("};");
  fwrite(str.e, str.count, 1, p->pack_id_file);
  fwrite(str.e, str.count, 1, p->bitmap_id_file);
  fwrite(str.e, str.count, 1, p->font_id_file);
  fwrite(str.e, str.count, 1, p->sprite_id_file);
  fwrite(str.e, str.count, 1, p->sound_id_file);
  
  // close the files
  fclose(p->pack_id_file);
  fclose(p->bitmap_id_file);
  fclose(p->font_id_file);
  fclose(p->sprite_id_file);
  fclose(p->sound_id_file);
}

static void
begin_asset_pack(Sui_Packer* p)
{ 
  p->bitmap_count = 0;
  p->sprite_count = 0;
  p->current_font = 0;
  p->font_count = 0;
  p->font_glyph_count = 0;
}

static U32
add_bitmap(Sui_Packer* p, U32 w, U32 h, U32* pixels, const char* bitmap_id_name) 
{
  assert(p->bitmap_count < array_count(p->bitmaps));
  
  Packer_Bitmap* bitmap = p->bitmaps + p->bitmap_count;
  bitmap->width = w;
  bitmap->height = h;
  bitmap->pixels = pixels;
  bitmap->bitmap_id_name = bitmap_id_name;
  
  return p->bitmap_count++;
}

static U32 
add_sprite(Sui_Packer* p, 
           U32 bitmap_id, 
           Rect2U texel_uv, 
           const char* sprite_id_name) 
{
  assert(p->sprite_count < array_count(p->sprites));
  
  Packer_Sprite* sprite = p->sprites + p->sprite_count;
  sprite->bitmap_id = bitmap_id;
  sprite->texel_uv = texel_uv;
  sprite->sprite_id_name = sprite_id_name;
  return p->sprite_count++;
}

static U32
begin_font(Sui_Packer* p) 
{ 
  assert(p->font_count < array_count(p->fonts));
  
  assert(p->current_font == nullptr);
  Packer_Font* font = p->fonts + p->font_count;
  font->glyph_start_index = p->font_glyph_count;
  font->one_past_glyph_end_index = font->glyph_start_index;
  
  p->current_font = font;
  return p->font_count++;
}

static void
push_glyph(Sui_Packer* p, Rect2U texel_uv, Rect2 uv, U32 codepoint) {
  Packer_Font* font = p->current_font;
  assert(font);
  assert(p->font_glyph_count < array_count(p->font_glyphs));
  
  Packer_Font_Glyph* glyph = p->font_glyphs + p->font_glyph_count++;
  glyph->texel_uv = texel_uv;
  glyph->uv = uv;
  glyph->codepoint = codepoint;
  
  if (codepoint > font->highest_codepoint) {
    font->highest_codepoint = codepoint;
  }
  
  // if there's no glyphs yet
  ++font->one_past_glyph_end_index;
  
  
}



static void
end_font(Sui_Packer* p, const char* font_id_name, const char* font_file_name, U32 bitmap_id) {
  Packer_Font* font = p->current_font;
  assert(font);
  font->font_id_name = font_id_name;
  font->bitmap_id = bitmap_id;
  font->font_file_name = font_file_name;
  
  font = nullptr;
  p->current_font = nullptr;
  
}

static U32
add_sound(Sui_Packer* p, const char* sound_id_name, WAV* wav) { 
  assert(p->sound_count < array_count(p->sounds));

  Packer_Sound* sound = p->sounds + p->sound_count;
  sound->sound_id_name = sound_id_name;
  sound->wav = wav;

  return p->sound_count++;
}

static void
add_atlas(Sui_Packer* p, Sui_Atlas* atlas) {
  
  U32 real_bitmap_id = add_bitmap(p, 
                                  atlas->bitmap.width,
                                  atlas->bitmap.height,
                                  atlas->bitmap.pixels,
                                  atlas->bitmap_id_name);
  U32 bitmap_id = 0 << 16 | real_bitmap_id;
  
  for (U32 sprite_index = 0; 
       sprite_index < atlas->sprite_count;
       ++sprite_index) 
  {
    Sui_Atlas_Sprite* sas = atlas->sprites + sprite_index;
    
    Rect2 uv = {};
    uv.min.x = (F32)sas->rect->x / atlas->bitmap.width;
    uv.min.y = (F32)sas->rect->y / atlas->bitmap.height;
    uv.max.x = (F32)(sas->rect->x+sas->rect->w) / atlas->bitmap.width;
    uv.max.y = (F32)(sas->rect->y+sas->rect->h) / atlas->bitmap.height;
    
    Rect2U texel_uv = {};
    texel_uv.min.x = sas->rect->x;
    texel_uv.min.y = sas->rect->y;
    texel_uv.max.x = sas->rect->x + sas->rect->w;
    texel_uv.max.y = sas->rect->y + sas->rect->h;
    
    
    add_sprite(p, bitmap_id, texel_uv, sas->sprite_id_name);
  }
  
  for (U32 font_index = 0; 
       font_index < atlas->font_count;
       ++font_index) 
  {
    begin_font(p);
    Sui_Atlas_Font* saf = atlas->fonts + font_index;
    
    U32 highest_codepoint = 0;
    for (U32 rect_index = 0;
         rect_index < saf->rect_count; 
         ++rect_index) 
    {
      RP_Rect* rect = saf->glyph_rects + rect_index;
      Sui_Atlas_Context* sac = saf->glyph_rect_contexts + rect_index;
      
      Rect2 uv = {};
      uv.min.x = (F32)rect->x / atlas->bitmap.width;
      uv.min.y = (F32)rect->y / atlas->bitmap.height;
      uv.max.x = (F32)(rect->x+rect->w) / atlas->bitmap.width;
      uv.max.y = (F32)(rect->y+rect->h) / atlas->bitmap.height;
      
      Rect2U texel_uv = {};
      texel_uv.min.x = rect->x;
      texel_uv.min.y = rect->y;
      texel_uv.max.x = rect->x + rect->w;
      texel_uv.max.y = rect->y + rect->h;
      
      push_glyph(p, texel_uv, uv, sac->font_glyph.codepoint);
    }
    
    end_font(p, saf->font_id_name, saf->font_file_name, bitmap_id);
  }
  
}



static void
end_asset_pack(Sui_Packer* p, 
               const char* pack_id_name,
               const char* filename, 
               Bump_Allocator* allocator) 

{
  sui_log("Starting writing to %s\n", filename);
  defer { sui_log("End writing to %s\n", filename); };
  
  FILE* file = fopen(filename, "wb");
  assert(file);
  defer { fclose(file); };
  
  
  // Packed in this order:
  // - Bitmap, Sprite, Font, Sound, Msgs
  Karu_Header header = {};
  header.signature = KARU_SIGNATURE;
  header.font_count = p->font_count;
  header.sprite_count = p->sprite_count;
  header.bitmap_count = p->bitmap_count;
  header.sound_count = p->sound_count;
  header.offset_to_bitmaps = sizeof(Karu_Header);
  header.offset_to_sprites = header.offset_to_bitmaps + sizeof(Karu_Bitmap)*p->bitmap_count;
  header.offset_to_fonts = header.offset_to_sprites + sizeof(Karu_Sprite)*p->sprite_count;
  header.offset_to_sounds = header.offset_to_fonts + sizeof(Karu_Sprite)*p->font_count;
  fwrite(&header, sizeof(header), 1, file);
  
  U32 offset_to_data = header.offset_to_fonts + sizeof(Karu_Font)*p->font_count;
  
  U8 buffer[256];
  declare_and_pointerize(String_Builder, builder);
  init_string_builder(builder, buffer, array_count(buffer));
  
  for (U32 bitmap_index = 0;
       bitmap_index < p->bitmap_count;
       ++bitmap_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing bitmap %u\n", bitmap_index);
    Packer_Bitmap* pb = p->bitmaps + bitmap_index;
    Karu_Bitmap kb = {};
    kb.width = pb->width;
    kb.height = pb->height;
    kb.offset_to_data = offset_to_data;
    fwrite(&kb, sizeof(Karu_Bitmap), 1, file);
    
    
    U32 current_pos = ftell(file);
    U32 image_size = kb.width * kb.height * 4;
    fseek(file, kb.offset_to_data, SEEK_SET);
    fwrite(pb->pixels, image_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += image_size;
    
    // Write to bitmap_id file
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, pb->bitmap_id_name, pack_id_name, bitmap_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    clear(builder);
  }
  
  for (U32 sprite_index = 0;
       sprite_index < p->sprite_count;
       ++sprite_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sprite %u\n", sprite_index);
    Packer_Sprite* ps = p->sprites + sprite_index;
    Karu_Sprite ks = {};
    ks.bitmap_id = ps->bitmap_id;
    ks.texel_uv = ps->texel_uv;
    fwrite(&ks, sizeof(Karu_Sprite), 1, file);
    
    // write sprite id
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, ps->sprite_id_name, pack_id_name, sprite_index);
    fwrite(builder->e, builder->count, 1, p->sprite_id_file);
    clear(builder);
  }
  
  for (U32 font_index = 0;
       font_index < p->font_count;
       ++font_index) 
  {
    ba_set_revert_point(allocator);
    sui_create_log_section_until_scope;
    sui_log("Writing font %u\n", font_index);
    Packer_Font* pf = p->fonts + font_index;
    Karu_Font kf = {};
    kf.bitmap_id = pf->bitmap_id;
    kf.highest_codepoint = pf->highest_codepoint;
    kf.glyph_count = pf->one_past_glyph_end_index - pf->glyph_start_index;
    kf.offset_to_data = offset_to_data;
    fwrite(&kf, sizeof(Karu_Font), 1, file);
    
    U32 current_pos = ftell(file);
    fseek(file, kf.offset_to_data, SEEK_SET);

    declare_and_pointerize(TTF, ttf);
    B32 ok = sui_read_font_from_file(ttf, pf->font_file_name, allocator);
    assert(ok);
    
    for (U32 glyph_index = pf->glyph_start_index;
         glyph_index < pf->one_past_glyph_end_index;
         ++glyph_index) 
    {
      Packer_Font_Glyph* pfg = p->font_glyphs + glyph_index;
      Karu_Font_Glyph kfg = {};
      
      kfg.texel_uv = pfg->texel_uv;
      kfg.uv = pfg->uv;
      kfg.codepoint = pfg->codepoint;
      

      U32 ttf_glyph_index = ttf_get_glyph_index(ttf,kfg.codepoint);
      F32 s = ttf_get_scale_for_pixel_height(ttf, 1.f);
      kfg.box = ttf_get_glyph_box(ttf, ttf_glyph_index, s);
      fwrite(&kfg, sizeof(kfg), 1, file);
      offset_to_data += sizeof(kfg);
    }
    
    for (U32 pgi1 = pf->glyph_start_index;
         pgi1 < pf->one_past_glyph_end_index;
         ++pgi1) 
    {
      F32 pixel_scale = ttf_get_scale_for_pixel_height(ttf, 1.f);
      
      Packer_Font_Glyph* pfg1 = p->font_glyphs + pgi1;
      for (U32 pgi2 = pf->glyph_start_index;
           pgi2 < pf->one_past_glyph_end_index;
           ++pgi2) 
      {
        Packer_Font_Glyph* pfg2 = p->font_glyphs + pgi2;
        
        U32 cp1 = pfg1->codepoint;
        U32 cp2 = pfg2->codepoint;
        
        U32 gi1 = ttf_get_glyph_index(ttf, cp1);
        U32 gi2 = ttf_get_glyph_index(ttf, cp2);
        
        auto g1_metrics = ttf_get_glyph_horiozontal_metrics(ttf, gi1);
        S32 raw_kern = ttf_get_glyph_kerning(ttf, gi1, gi2);
        
        F32 advance_width = (F32)g1_metrics.advance_width * pixel_scale;
        F32 kerning = (F32)raw_kern * pixel_scale;
        
        F32 advance = advance_width + kerning;
        fwrite(&advance, sizeof(advance), 1, file);
        offset_to_data += sizeof(advance);
        
      }
      
    }
    
    
    fseek(file, current_pos, SEEK_SET);
    
    // write font id
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, pf->font_id_name, pack_id_name, font_index);
    fwrite(builder->e, builder->count, 1, p->font_id_file);
    clear(builder);
  }


  for(U32 sound_index = 0;
      sound_index < p->sound_count;
      ++sound_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sound %u\n", sound_index);
    Packer_Sound* ps = p->sounds + sound_index;
    Karu_Sound ks = {};
    ks.offset_to_data = offset_to_data;
    ks.data_count = ps->wav->data_chunk.size / sizeof(S16);
    fwrite(&ks, sizeof(Karu_Sound), 1, file);

    U32 current_pos = ftell(file);
    U32 data_size = ps->wav->data_chunk.size;
    fseek(file, ks.offset_to_data, SEEK_SET);
    fwrite(ps->wav->data, data_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += data_size;

    // Write to sound_id file
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, ps->sound_id_name, pack_id_name, sound_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    clear(builder);

  }

  
  // Write the header
  fseek(file, 0, SEEK_SET);
  fwrite(&header, sizeof(header), 1, file);
  
  // Write the pack id
  {
    String format = string_from_lit("%s = %u,\n");
    push_format(builder, format, pack_id_name, p->pack_count);
    fwrite(builder->e, builder->count, 1, p->pack_id_file);
    clear(builder);
    ++p->pack_count;
    
  }
  
}


#endif //SUI_PACK_H
