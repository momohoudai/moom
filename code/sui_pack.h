#ifndef SUI_PACK_H
#define SUI_PACK_H

#include <stdio.h>
#include "sui_atlas.h"
#include "karu.h"
#include "momo_common.h"
#include "momo_shapes.h"
#include "momo_ttf.h"
#include "momo_strings.h"

struct Sui_Packer_Font_Glyph {
  Rect2 uv;
  Rect2U texel_uv;
  U32 codepoint;
};

#if 0

#endif 

struct Sui_Packer_Bitmap {
  U32 width;
  U32 height;
  U32* pixels;
  const C8* id_name;
};

#if 0
struct Sui_Packer_Sprite {
  U32 bitmap_id;
  Rect2U texel_uv;
  const char* sprite_id_name;
};
struct Sui_Packer_Font {
  U32 bitmap_id;
  U32 highest_codepoint;
  const char* font_file_name;
  
  U32 glyph_start_index;
  U32 one_past_glyph_end_index;
  
  const char* font_id_name;
};
#else 
struct Sui_Packer_Sprite {
  const C8* filename;
  const C8* sprite_id_name;
  U32 bitmap_id;

};

struct Sui_Packer_Font {
  const char* id_name;
  const char* file_name;
  const U32* codepoints;
  const U32 codepoint_count;
  U32 bitmap_id;
};
#endif

struct Sui_Packer_Sound {
  const char* sound_id_name;
  WAV* wav;
};


struct Sui_Packer {
  FILE* pack_id_file;
  U32 pack_count;
  const char* current_pack_id_name;

  FILE* bitmap_id_file;
  FILE* font_id_file;
  FILE* sprite_id_file;
  FILE* sound_id_file;
  

  U32 bitmap_count;
  Sui_Packer_Bitmap bitmaps[128];
  
  U32 sprite_count;
  Sui_Packer_Sprite sprites[128];
  
  U32 sound_count;
  Sui_Packer_Sound sounds[128];

  Sui_Packer_Font* current_font;
  
  U32 font_count;
  U32 font_glyph_count;
  Sui_Packer_Font fonts[128];
  Sui_Packer_Font_Glyph font_glyphs[128];

  // For atlas building
  U32 current_atlas_bitmap_id;
  U32 first_atlas_sprite_id;
  U32 ope_atlas_sprite_id;
  U32 first_atlas_font_id;
  U32 ope_atlas_font_id;

};


/////////////////////////////////////////////////////
// IMPLEMENTATION
//
static B32
begin_packer(Sui_Packer* p,
             const char* pack_id_filename,
             const char* bitmap_id_filename,
             const char* sprite_id_filename,
             const char* font_id_filename,
             const char* sound_id_filename)
{
   
  p->pack_id_file = fopen(pack_id_filename, "w");
  p->bitmap_id_file = fopen(bitmap_id_filename, "w");
  p->font_id_file = fopen(font_id_filename, "w");
  p->sprite_id_file = fopen(sprite_id_filename, "w");
  p->sound_id_file = fopen(sound_id_filename, "w");

  if (!p->pack_id_file) return false;
  if (!p->bitmap_id_file) return false;
  if (!p->font_id_file) return false;
  if (!p->sprite_id_file) return false;
  if (!p->sound_id_file) return false;
  
  // boiler plate:
  {
    String boiler = string_from_lit("// Generated by sui\n");
    fwrite(boiler.e, boiler.count, 1, p->pack_id_file);
    fwrite(boiler.e, boiler.count, 1, p->bitmap_id_file);
    fwrite(boiler.e, boiler.count, 1, p->font_id_file);
    fwrite(boiler.e, boiler.count, 1, p->sprite_id_file);
    fwrite(boiler.e, boiler.count, 1, p->sound_id_file);
  }
  
  
  String str = {};
  str = string_from_lit("enum Pack_ID {\n");
  fwrite(str.e, str.count, 1, p->pack_id_file);
  str = string_from_lit("enum Bitmap_ID {\n");
  fwrite(str.e, str.count, 1, p->bitmap_id_file);
  str = string_from_lit("enum Font_ID {\n");
  fwrite(str.e, str.count, 1, p->font_id_file);
  str = string_from_lit("enum Sprite_ID {\n");
  fwrite(str.e, str.count, 1, p->sprite_id_file);
  str = string_from_lit("enum Sound_ID {\n");
  fwrite(str.e, str.count, 1, p->sound_id_file);

  return true;
}


static void
end_packer(Sui_Packer* p) {
  String str = {};
  str = string_from_lit("};");
  fwrite(str.e, str.count, 1, p->pack_id_file);
  fwrite(str.e, str.count, 1, p->bitmap_id_file);
  fwrite(str.e, str.count, 1, p->font_id_file);
  fwrite(str.e, str.count, 1, p->sprite_id_file);
  fwrite(str.e, str.count, 1, p->sound_id_file);
  
  // close the files
  fclose(p->pack_id_file);
  fclose(p->bitmap_id_file);
  fclose(p->font_id_file);
  fclose(p->sprite_id_file);
  fclose(p->sound_id_file);
}

static void
begin_asset_pack(Sui_Packer* p)
{ 
  p->bitmap_count = 0;
  p->sprite_count = 0;
  p->current_font = 0;
  p->font_count = 0;
  p->font_glyph_count = 0;
}

static void 
begin_atlas(Sui_Packer *p) {
  assert(p->bitmap_count < array_count(p->bitmaps));
  p->current_atlas_bitmap_id = p->bitmap_count++;

  p->first_atlas_sprite_id = p->sprite_count;
  p->ope_atlas_sprite_id = p->first_atlas_sprite_id;

  p->first_atlas_font_id = p->font_count;
  p->ope_atlas_font_id = p->first_atlas_font_id;
}

static B32 
end_atlas(Sui_Packer* p, const char* id_name, U32 width, U32 height)
{
  Sui_Packer_Bitmap* bmp = p->bitmaps + p->current_atlas_bitmap_id;

  bmp->width = width;
  bmp->height = height;
  bmp->pixels = ba_push_array<U32>(p->allocator, w * h);
  bmp->id_name = id_name;

  if (!bmp->pixels) return false; 
   
  // Count the amount of rects
  U32 rect_count = p->ope_atlas_sprite_id - p->first_atlas_sprite_id;
  {
    for (U32 font_id = p->first_atlas_font_id;
         font_id < p->ope_atlas_font_id;
         ++font_id)
    {
      rect_count += fonts[font_id].codepoint_count;
    }
  }

  if (rect_count == 0) return false;

  auto* rects = ba_push_array<RP_Rect>(p->allocator, rect_count);
  if (!rects) return false;

  ba_set_revert_point(p->allocator);
  U32 rect_index = 0;

  for (U32 font_id = p->first_atlas_font_id;
       font_id < p->ope_atlas_font_id;
       ++font_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Font* font = p->fonts + font_id;

    declare_and_pointerize(TTF, ttf);
    if (!sui_read_font_from_file(ttf, font->file_name, allocator))
      return false; 

    F32 s = ttf_get_scale_for_pixel_height(ttf, font->raster_font_height);
    
    // grab the slice of RP_Rects that belongs to this font
    font->glyph_rects = rects + rect_index;
    font->glyph_rect_contexts = contexts + context_index;
    font->rect_count = 0;
    
    for (U32 cpi = 0; cpi < font->codepoint_count; ++cpi) {
      U32 cp = font->codepoints[cpi];
      U32 glyph_index = ttf_get_glyph_index(ttf, cp);
      Rect2 box = ttf_get_glyph_box(ttf, glyph_index, s);
      V2U dims = ttf_get_bitmap_dims_from_glyph_box(box);
      
      RP_Rect* rect = rects + rect_index++;
      rect->w = dims.w;
      rect->h = dims.h;
      
      // TODO: set font's RP_Rect to this
    
  }
  for (U32 sprite_id = p->first_atlas_sprite_id;
       sprite_id < p->ope_atlas_sprite_id;
       ++sprite_id)
  {
    ba_set_revert_point(p->allocator);
    Sui_Packer_Sprite* sprite = p->sprites + sprite_id;
    declare_and_pointerize(Memory, mem);
    declare_and_pointerize(PNG, png);
    if (!sui_read_file_to_memory(mem, sprite_filename, p->allocator))
      return false;
    if (!png_read(png, mem->data, mem->size)) 
      return false;
   
    RP_Rect* rect = rects + rect_index++;
    rect->w = png->width;
    rect->h = png->height;

    sprite->rect = rect;

  }

  // Pack the rects
  rp_pack(rects, rect_count, 1, bmp->width, bmp->height, RP_SORT_TYPE_HEIGHT, p->allocator);
}

static void
push_atlas_sprite(Sui_Packer* p, const char* id_name, const char* file_name) {
  assert(p->sprite_count < array_count(p->sprites));
  Sui_Packer_Sprite* s = p->sprites + p->sprite_count++;
  s->file_name = file_name;
  s->id_name = id_name;
  s->bitmap_id = p->current_atlas_bitmap_id;
}

static void
push_atlas_font(Sui_Packer* p, 
                const C8* font_id_name,
                const C8* filename, 
                const U32* codepoints, 
                U32 codepoint_count)
{
  assert(p->font_count < array_count(p->fonts));
  Sui_Packer_Font* f = p->fonts + p->font_count++;
  f->id_name = id_name;
  f->file_name = file_name
  f->codepoints = codepoints;
  f->codepoint_count = codepoint_count;
  f->bitmap_id = p->current_atlas_bitmap_id;
}

#if 0
static U32
push_bitmap(Sui_Packer* p, 
            U32 w, U32 h, 
            U32* pixels, 
            const char* bitmap_id_name) 
{
  assert(p->bitmap_count < array_count(p->bitmaps));
  
  Sui_Packer_Bitmap* bitmap = p->bitmaps + p->bitmap_count;
  bitmap->width = w;
  bitmap->height = h;
  bitmap->pixels = pixels;
  bitmap->bitmap_id_name = bitmap_id_name;
  
  return p->bitmap_count++;
}

static U32 
add_sprite(Sui_Packer* p, 
           U32 bitmap_id, 
           Rect2U texel_uv, 
           const char* sprite_id_name) 
{
  assert(p->sprite_count < array_count(p->sprites));
  
  Sui_Packer_Sprite* sprite = p->sprites + p->sprite_count;
  sprite->bitmap_id = bitmap_id;
  sprite->texel_uv = texel_uv;
  sprite->sprite_id_name = sprite_id_name;
  return p->sprite_count++;
}

static U32
begin_font(Sui_Packer* p) 
{ 
  assert(p->font_count < array_count(p->fonts));
  assert(p->current_font == nullptr);
  Sui_Packer_Font* font = p->fonts + p->font_count;
  font->glyph_start_index = p->font_glyph_count;
  font->one_past_glyph_end_index = font->glyph_start_index;
  
  p->current_font = font;
  return p->font_count++;
}

static void
push_glyph(Sui_Packer* p, Rect2U texel_uv, Rect2 uv, U32 codepoint) {
  Sui_Packer_Font* font = p->current_font;
  assert(font);
  assert(p->font_glyph_count < array_count(p->font_glyphs));
  
  Sui_Packer_Font_Glyph* glyph = p->font_glyphs + p->font_glyph_count++;
  glyph->texel_uv = texel_uv;
  glyph->uv = uv;
  glyph->codepoint = codepoint;
  
  if (codepoint > font->highest_codepoint) {
    font->highest_codepoint = codepoint;
  }
  
  // if there's no glyphs yet
  ++font->one_past_glyph_end_index;
}



static void
end_font(Sui_Packer* p, const char* font_id_name, const char* font_file_name, U32 bitmap_id) {
  Sui_Packer_Font* font = p->current_font;
  assert(font);
  font->font_id_name = font_id_name;
  font->bitmap_id = bitmap_id;
  font->font_file_name = font_file_name;
  
  font = nullptr;
  p->current_font = nullptr;
  
}
#endif

static U32
push_sound(Sui_Packer* p, const char* sound_id_name, WAV* wav) { 
  assert(p->sound_count < array_count(p->sounds));

  Sui_Packer_Sound* sound = p->sounds + p->sound_count;
  sound->sound_id_name = sound_id_name;
  sound->wav = wav;

  return p->sound_count++;
}


#if 0
static void
add_atlas(Sui_Packer* p, Sui_Atlas* atlas) {
  U32 real_bitmap_id = add_bitmap(p, 
                                  atlas->bitmap.width,
                                  atlas->bitmap.height,
                                  atlas->bitmap.pixels,
                                  atlas->bitmap_id_name);
  U32 bitmap_id = 0 << 16 | real_bitmap_id;
  
  for (U32 sprite_index = 0; 
       sprite_index < atlas->sprite_count;
       ++sprite_index) 
  {
    Sui_Atlas_Sprite* sas = atlas->sprites + sprite_index;
    
    Rect2 uv = {};
    uv.min.x = (F32)sas->rect->x / atlas->bitmap.width;
    uv.min.y = (F32)sas->rect->y / atlas->bitmap.height;
    uv.max.x = (F32)(sas->rect->x+sas->rect->w) / atlas->bitmap.width;
    uv.max.y = (F32)(sas->rect->y+sas->rect->h) / atlas->bitmap.height;
    
    Rect2U texel_uv = {};
    texel_uv.min.x = sas->rect->x;
    texel_uv.min.y = sas->rect->y;
    texel_uv.max.x = sas->rect->x + sas->rect->w;
    texel_uv.max.y = sas->rect->y + sas->rect->h;
    
    add_sprite(p, bitmap_id, texel_uv, sas->sprite_id_name);
  }
  
  for (U32 font_index = 0; 
       font_index < atlas->font_count;
       ++font_index) 
  {
    begin_font(p);
    Sui_Atlas_Font* saf = atlas->fonts + font_index;
    
    U32 highest_codepoint = 0;
    for (U32 rect_index = 0;
         rect_index < saf->rect_count; 
         ++rect_index) 
    {
      RP_Rect* rect = saf->glyph_rects + rect_index;
      Sui_Atlas_Context* sac = saf->glyph_rect_contexts + rect_index;
      
      Rect2 uv = {};
      uv.min.x = (F32)rect->x / atlas->bitmap.width;
      uv.min.y = (F32)rect->y / atlas->bitmap.height;
      uv.max.x = (F32)(rect->x+rect->w) / atlas->bitmap.width;
      uv.max.y = (F32)(rect->y+rect->h) / atlas->bitmap.height;
      
      Rect2U texel_uv = {};
      texel_uv.min.x = rect->x;
      texel_uv.min.y = rect->y;
      texel_uv.max.x = rect->x + rect->w;
      texel_uv.max.y = rect->y + rect->h;
      
      push_glyph(p, texel_uv, uv, sac->font_glyph.codepoint);
    }
    
    end_font(p, saf->font_id_name, saf->font_file_name, bitmap_id);
  }
  
}
#endif



static B32
end_asset_pack(Sui_Packer* p, 
               const char* pack_id_name,
               const char* filename, 
               Bump_Allocator* allocator) 

{
  sui_log("Starting writing to %s\n", filename);
  defer { sui_log("End writing to %s\n", filename); };
  
  FILE* file = fopen(filename, "wb");
  if (file) return false;
  defer { fclose(file); };
  


  
  // Packed in this order:
  // - Bitmap, Sprite, Font, Sound, Msgs
  Karu_Header header = {};
  {
    header.signature = KARU_SIGNATURE;
    header.font_count = p->font_count;
    header.sprite_count = p->sprite_count;
    header.bitmap_count = p->bitmap_count;
    header.sound_count = p->sound_count;
    header.offset_to_bitmaps = sizeof(Karu_Header);
    header.offset_to_sprites = header.offset_to_bitmaps + sizeof(Karu_Bitmap)*p->bitmap_count;
    header.offset_to_fonts = header.offset_to_sprites + sizeof(Karu_Sprite)*p->sprite_count;
    header.offset_to_sounds = header.offset_to_fonts + sizeof(Karu_Sprite)*p->font_count;
    fwrite(&header, sizeof(header), 1, file);
  }
  
  U32 offset_to_data = header.offset_to_fonts + sizeof(Karu_Font)*p->font_count;
  
  U8 buffer[256];
  declare_and_pointerize(String_Builder, builder);
  init_string_builder(builder, buffer, array_count(buffer));
  
  for (U32 bitmap_index = 0;
       bitmap_index < p->bitmap_count;
       ++bitmap_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing bitmap %u\n", bitmap_index);
    Sui_Packer_Bitmap* pb = p->bitmaps + bitmap_index;
    Karu_Bitmap kb = {};
    kb.width = pb->width;
    kb.height = pb->height;
    kb.offset_to_data = offset_to_data;
    fwrite(&kb, sizeof(Karu_Bitmap), 1, file);
    
    
    U32 current_pos = ftell(file);
    U32 image_size = kb.width * kb.height * 4;
    fseek(file, kb.offset_to_data, SEEK_SET);
    fwrite(pb->pixels, image_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += image_size;
    
    // Write to bitmap_id file
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, pb->bitmap_id_name, pack_id_name, bitmap_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    clear(builder);
  }
  
  for (U32 sprite_index = 0;
       sprite_index < p->sprite_count;
       ++sprite_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sprite %u\n", sprite_index);
    Sui_Packer_Sprite* ps = p->sprites + sprite_index;
    Karu_Sprite ks = {};
    ks.bitmap_id = ps->bitmap_id;
    ks.texel_uv = ps->texel_uv;
    fwrite(&ks, sizeof(Karu_Sprite), 1, file);
    
    // write sprite id
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, ps->sprite_id_name, pack_id_name, sprite_index);
    fwrite(builder->e, builder->count, 1, p->sprite_id_file);
    clear(builder);
  }
  
  for (U32 font_index = 0;
       font_index < p->font_count;
       ++font_index) 
  {
    ba_set_revert_point(allocator);
    sui_create_log_section_until_scope;
    sui_log("Writing font %u\n", font_index);
    Sui_Packer_Font* pf = p->fonts + font_index;
    Karu_Font kf = {};
    kf.bitmap_id = pf->bitmap_id;
    kf.highest_codepoint = pf->highest_codepoint;
    kf.glyph_count = pf->one_past_glyph_end_index - pf->glyph_start_index;
    kf.offset_to_data = offset_to_data;
    fwrite(&kf, sizeof(Karu_Font), 1, file);
    
    U32 current_pos = ftell(file);
    fseek(file, kf.offset_to_data, SEEK_SET);

    declare_and_pointerize(TTF, ttf);
    B32 ok = sui_read_font_from_file(ttf, pf->font_file_name, allocator);
    assert(ok);
    
    for (U32 glyph_index = pf->glyph_start_index;
         glyph_index < pf->one_past_glyph_end_index;
         ++glyph_index) 
    {
      Sui_Packer_Font_Glyph* pfg = p->font_glyphs + glyph_index;
      Karu_Font_Glyph kfg = {};
      
      kfg.texel_uv = pfg->texel_uv;
      kfg.uv = pfg->uv;
      kfg.codepoint = pfg->codepoint;
      

      U32 ttf_glyph_index = ttf_get_glyph_index(ttf,kfg.codepoint);
      F32 s = ttf_get_scale_for_pixel_height(ttf, 1.f);
      kfg.box = ttf_get_glyph_box(ttf, ttf_glyph_index, s);
      fwrite(&kfg, sizeof(kfg), 1, file);
      offset_to_data += sizeof(kfg);
    }
    
    for (U32 pgi1 = pf->glyph_start_index;
         pgi1 < pf->one_past_glyph_end_index;
         ++pgi1) 
    {
      F32 pixel_scale = ttf_get_scale_for_pixel_height(ttf, 1.f);
      
      Sui_Packer_Font_Glyph* pfg1 = p->font_glyphs + pgi1;
      for (U32 pgi2 = pf->glyph_start_index;
           pgi2 < pf->one_past_glyph_end_index;
           ++pgi2) 
      {
        Sui_Packer_Font_Glyph* pfg2 = p->font_glyphs + pgi2;
        
        U32 cp1 = pfg1->codepoint;
        U32 cp2 = pfg2->codepoint;
        
        U32 gi1 = ttf_get_glyph_index(ttf, cp1);
        U32 gi2 = ttf_get_glyph_index(ttf, cp2);
        
        auto g1_metrics = ttf_get_glyph_horiozontal_metrics(ttf, gi1);
        S32 raw_kern = ttf_get_glyph_kerning(ttf, gi1, gi2);
        
        F32 advance_width = (F32)g1_metrics.advance_width * pixel_scale;
        F32 kerning = (F32)raw_kern * pixel_scale;
        
        F32 advance = advance_width + kerning;
        fwrite(&advance, sizeof(advance), 1, file);
        offset_to_data += sizeof(advance);
        
      }
      
    }
    
    
    fseek(file, current_pos, SEEK_SET);
    
    // write font id
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, pf->font_id_name, pack_id_name, font_index);
    fwrite(builder->e, builder->count, 1, p->font_id_file);
    clear(builder);
  }


  for(U32 sound_index = 0;
      sound_index < p->sound_count;
      ++sound_index) 
  {
    sui_create_log_section_until_scope;
    sui_log("Writing sound %u\n", sound_index);
    Sui_Packer_Sound* ps = p->sounds + sound_index;
    Karu_Sound ks = {};
    ks.offset_to_data = offset_to_data;
    ks.data_count = ps->wav->data_chunk.size / sizeof(S16);
    fwrite(&ks, sizeof(Karu_Sound), 1, file);

    U32 current_pos = ftell(file);
    U32 data_size = ps->wav->data_chunk.size;
    fseek(file, ks.offset_to_data, SEEK_SET);
    fwrite(ps->wav->data, data_size, 1, file);
    fseek(file, current_pos, SEEK_SET);
    
    offset_to_data += data_size;

    // Write to sound_id file
    String format = string_from_lit("%s = %s << 16 | %u,\n");
    push_format(builder, format, ps->sound_id_name, pack_id_name, sound_index);
    fwrite(builder->e, builder->count, 1, p->bitmap_id_file);
    clear(builder);

  }

  
  // Write the header
  fseek(file, 0, SEEK_SET);
  fwrite(&header, sizeof(header), 1, file);
  
  // Write the pack id
  {
    String format = string_from_lit("%s = %u,\n");
    push_format(builder, format, pack_id_name, p->pack_count);
    fwrite(builder->e, builder->count, 1, p->pack_id_file);
    clear(builder);
    ++p->pack_count;
    
  }
  
  return true;
  
}


#endif //SUI_PACK_H
